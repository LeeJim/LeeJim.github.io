import{_ as a,o as e,c as n,k as s,a as l,t as p,S as t}from"./chunks/framework.c5ba3aa3.js";const u=JSON.parse('{"title":"Promise 原理 & 宏微任务","description":"","frontmatter":{"title":"Promise 原理 & 宏微任务","date":"2021-01-17T14:59:13.000Z","tags":["promise"],"toc":true,"categories":[["前端基础"]]},"headers":[],"relativePath":"fe-base/promise.md","filePath":"fe-base/promise.md","lastUpdated":1691668833000}'),r={name:"fe-base/promise.md"},c={id:"frontmatter-title",tabindex:"-1"},i=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),y=t(`<p>读完这篇文章，你的收获有：</p><ol><li>Promise简史</li><li>Promise的关键概念</li><li>可以手写符合标准的Promise</li><li>可以解答任意宏任务/微任务的题目</li></ol><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>为什么写这篇文章？</p><p>JavaScript是异步语言，因此Promise的重要性不言而喻。</p><p>而我看了一些文章，觉得质量参差不齐。</p><p>于是就系统地整理了些资料，然后输出一篇文章，即帮助他人，也能让大家给我挑问题，避免自己错而不知。</p><p>由于能力有限，文中可能存在错误，望广大网友指正。</p><h2 id="promise-简史" tabindex="-1">Promise 简史 <a class="header-anchor" href="#promise-简史" aria-label="Permalink to &quot;Promise 简史&quot;">​</a></h2><p>Promise 并不是一个新鲜的概念，早在2011年就出现在社区里了，目的是为了解决著名的回调地狱问题。</p><p>这个概念是在JQuery Deferred Objects出现之后，开始流行的。并于2012年，Promise被提出作为规范：<a href="https://promisesaplus.com" target="_blank" rel="noreferrer">Promise/A+</a>。</p><p>在成为ES6标准之前，社区里也出现了许多符合Promise标准的库，如bluebird、q、when等等。</p><h2 id="promise-的关键概念" tabindex="-1">Promise 的关键概念 <a class="header-anchor" href="#promise-的关键概念" aria-label="Permalink to &quot;Promise 的关键概念&quot;">​</a></h2><blockquote><p>“The Promise object is used for deferred and asynchronous computations. A Promise represents an operation that hasn’t completed yet, but is expected in the future.” — MDN Promise Reference</p></blockquote><p>Promise的基础认知，推荐看阮一峰的<a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noreferrer">《ES6 入门教程》</a>。</p><p>本文的重点是讲解一些手写Promise需要关注的关键概念。</p><h3 id="promise-有三个状态" tabindex="-1">Promise 有三个状态： <a class="header-anchor" href="#promise-有三个状态" aria-label="Permalink to &quot;Promise 有三个状态：&quot;">​</a></h3><ul><li>pending</li><li>resolved</li><li>rejected</li></ul><p>只能从pending到resolved或rejected，之后状态就凝固了。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0704fc368da4c8cb5acee94a1659a1b~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>当状态流转成resolved时，需要选择一个值作为当前Promise的value：</p><ul><li><code>new Promise</code>时，则是通过<code>resolve(val)</code></li><li><code>promise.then</code>时，则是通过<code>return</code>（需要注意的是，没有显式<code>return</code>时是默认<code>return undefined</code>）</li></ul><p>这个值可以是任意的合法JavaScript值（包括<code>undefined</code>、<code>thenable对象</code>或者<code>promise</code>）</p><blockquote><p>thenable对象是一个定义了then方法的对象或者函数</p></blockquote><p>状态流转成rejected时，则需要用一个reason来作为当前Promise被reject的理由，和resolved时同理。</p><h3 id="promise-prototype-then" tabindex="-1">Promise.prototype.then <a class="header-anchor" href="#promise-prototype-then" aria-label="Permalink to &quot;Promise.prototype.then&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(onFulfilled</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> onRejected)</span></span></code></pre></div><ul><li><a href="https://promisesaplus.com/" target="_blank" rel="noreferrer">Promise/A+</a> 是Promise的标准规范，<strong>其中指出Promise实例只需要实现then一个方法</strong></li><li>then接收两个参数，而两个参数都是可选的，意味着可以什么都不传</li><li>then是可以调用多次的。会按顺序调用，并且每次得到的promise状态和值都是相同的</li><li>每次调用then均返回一个全新的Promise实例，这样就可以链式调用</li><li>then会在当前宏任务下形成一个微任务（具体介绍看下面）</li></ul><h4 id="promise-的状态" tabindex="-1">Promise 的状态 <a class="header-anchor" href="#promise-的状态" aria-label="Permalink to &quot;Promise 的状态&quot;">​</a></h4><p>then其实和Promise的构造函数是类似的，返回值都是一个新的Promise实例。</p><p>它们之前的差异在于，通过构造函数生成的promise的状态，由构造函数自身决定：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">reject</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// 将当前的状态流转成resolved</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>而then返回的promise的状态判断需要分两步走：</p><ol><li>then的回调函数能否处理上一个promise的状态，否则直接复用上一个promise的状态</li><li>若满足条件1，则看当前回调函数能否正常处理</li></ol><p>说得有点绕口，看下面的实例代码即可理解：</p><p><strong>理解条件1：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> p1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">reject</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// Promise {&lt;rejected&gt;: &quot;error1&quot;}</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">reject</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">error1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> p2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> p1</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(console</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">log) </span><span style="color:#676E95;font-style:italic;">// Promise {&lt;rejected&gt;: &quot;error1&quot;}</span></span></code></pre></div><p>由于<code>p1</code>的状态是<code>Rejected</code>的，而<code>p2</code>没有传入<code>onRejected</code>的回调函数，因此<code>p2</code>的状态完全复用<code>p1</code>的状态。</p><p><strong>理解条件2：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> p1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">reject</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// Promise {&lt;fulfilled&gt;: 1}</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> p2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> p1</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;font-style:italic;">val</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// Promise {&lt;rejected&gt;: ReferenceError: x is not defined}</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">p1 was resolved:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">val</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// Uncaught referenceError</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> p3 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> p2</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">undefined,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">reason</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// Promise {&lt;fulfilled&gt;: 1}</span></span></code></pre></div><p><code>p1</code>的状态是<code>fulfilled</code>的，而<code>p2</code>有<code>onFulfilled</code>的回调函数，但是没有正确处理，抛异常了。因此<code>p2</code>的状态变成了<code>rejected</code>，其中的reason为则报错的原因。</p><p>而此时<code>p3</code>刚好有<code>onRejected</code>的函数，也能正确处理，最后的返回值则是自己的value，因此<code>p3</code>的状态是<code>fulfilled</code>的。</p><h4 id="promise-的返回值" tabindex="-1">Promise 的返回值 <a class="header-anchor" href="#promise-的返回值" aria-label="Permalink to &quot;Promise 的返回值&quot;">​</a></h4><p>前文也提到，promise的返回值可以是任意合法的JavaScript值，包括了<code>promise</code>，这里重点讲下。</p><p>由于promise的返回值决定了当前promise的value，而value是其他的promise时，则说明value是未知的，依赖其他的promise的状态。</p><p>同样看看例子：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> p1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">) </span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> p2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> p1)</span></span></code></pre></div><p><code>p1</code>是一个简单的定时器promise，在1000ms之后，状态会变成<code>&lt;fulfilled: 1&gt;</code>。</p><p>而<code>p2</code>的返回值是<code>p1</code>，因此<code>p2</code>在1000ms之内也是<code>&lt;pending&gt;</code>，同样会在1000ms之后，变成<code>&lt;fulfilled: 1&gt;</code></p><h3 id="promise-prototype-catch" tabindex="-1">Promise.prototype.catch <a class="header-anchor" href="#promise-prototype-catch" aria-label="Permalink to &quot;Promise.prototype.catch&quot;">​</a></h3><p>虽然catch不是Promise/A+标准的方法，但是也需要提一下，因为这也是常用的方法之一。</p><p>其实，catch可以理解成then的一种封装：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">catch</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">onRejected</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">undefined,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">onRejected</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><h3 id="微任务-microtask" tabindex="-1">微任务 microtask <a class="header-anchor" href="#微任务-microtask" aria-label="Permalink to &quot;微任务 microtask&quot;">​</a></h3><p>当前promise的状态变更之后，不是立即执行then方法的。此时引入了 <strong>微任务(microtask)</strong> 的概念。</p><p>与之对应的则是 <strong>宏任务(macrotask)</strong>，基本的JavaScript代码则是在一个宏任务里执行的。</p><p>也可以通过其他的方式生成宏任务：<code>setTimeout</code>、<code>setInterval</code>；而微任务则可以通过<code>promise.then</code>、<code>Object.observe(已废弃)</code>、<code>MutationObserver</code>生成。</p><p>宏任务和微任务的关系则是这样的（此处引入winter老师在《重新前端》画的图）：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/167014f8fe4d4befa1dc6bde5cf43ec4~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>即一个宏任务下，是可以有多个微任务的。</p><blockquote><p>由于微任务的机制是引擎提供的，因此手写Promise的时候，可以用setTimeout来代替。</p></blockquote><h4 id="解析任务" tabindex="-1">解析任务 <a class="header-anchor" href="#解析任务" aria-label="Permalink to &quot;解析任务&quot;">​</a></h4><p>分析代码的时候，可以这样分几步走：</p><ol><li>理想情况下，如果没有任何<code>setTimeout</code>和<code>promise.then</code>的话，则全部在一个宏任务里执行</li><li>若出现<code>promise.then</code>，则在当前宏任务生成一个微任务，用于执行<code>promise.then</code></li><li>若出现了<code>setTimeout</code>，则添加一个宏任务，重复条件1</li></ol><p>分析几个例子考验一下：</p><p><strong>例子1：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(console</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">log</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(console</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">log)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><details><summary><b>正确的输出顺序：</b></summary><p> 1、3、2、0 </p></details><p><strong>例子2：</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">8</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">4</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">log</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// 省略参数，delay默认为0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(console</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">log)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(console</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">log</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><details><summary><b>正确的输出顺序：</b></summary><p> 8、1、3、2、0、4、5 </p></details><p>其实，还有<code>async/await</code>相关的题目，如果阅读足够多的话，我再完善吧。</p><h2 id="手写-promise" tabindex="-1">手写 Promise <a class="header-anchor" href="#手写-promise" aria-label="Permalink to &quot;手写 Promise&quot;">​</a></h2><p>其实，看到这里说明你已经掌握了几乎全部关键概念了。剩下的任务就是将这些逻辑翻译成代码。</p><p>我在<a href="https://github.com/LeeJim/word" target="_blank" rel="noreferrer">github</a>写了一份，代码逻辑都算挺清晰的，大家可以去看看。</p><p>我建议大家在写之前，再仔细看一下<code>Promise/A+</code>的标准规范，可以结合我的代码一起看。</p><p>清晰理解细节之后，再动手写一遍。</p><p>如果觉得不错的话，记得给我点赞 + <a href="https://github.com/LeeJim/word" target="_blank" rel="noreferrer">star</a>。</p><p>撒花，感谢阅读！</p>`,79);function A(o,C,F,D,d,m){return e(),n("div",null,[s("h1",c,[l(p(o.$frontmatter.title)+" ",1),i]),y])}const f=a(r,[["render",A]]);export{u as __pageData,f as default};
