import{_ as n,o as l,c as p,k as s,a as t,t as o,S as e}from"./chunks/framework.7f03344f.js";const c="/miniprogram/user-agent.png",r="/miniprogram/css-cascade.png",i="/miniprogram/eventflow.svg",_=JSON.parse('{"title":"小程序按钮组件的亿点细节","description":"","frontmatter":{"title":"小程序按钮组件的亿点细节","date":"2022-01-25T22:40:19.000Z","tags":null,"toc":true,"categories":["小程序"]},"headers":[],"relativePath":"miniprogram/custom-button.md","filePath":"miniprogram/custom-button.md","lastUpdated":null}'),F={name:"miniprogram/custom-button.md"},D={id:"frontmatter-title",tabindex:"-1"},y=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),d=e('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>TDesign 的 button 是之前的同事开发的，我接手过来只是做了样式的调整，因此对组件的实现没有很清楚。最近有用户反馈传了 disabled 之后仍然会触发 tap 事件。我的第一反应以为是个小问题，就是漏掉了透传 disabled 而已，但我发现问题没这么简单，于是便有了这篇小文章。</p><h2 id="透传-disabled-属性" tabindex="-1">透传 disabled 属性 <a class="header-anchor" href="#透传-disabled-属性" aria-label="Permalink to &quot;透传 disabled 属性&quot;">​</a></h2><p>将 disabled 透传至 button 之后，就发现 user agent 的样式权重很高：</p><p><img src="'+c+'" alt="小程序最终样式"></p><p>这其实是小程序的坑。按理说 user agent stylesheet 的优先级肯定比 user stylesheet 低才合理的:</p><p><img src="'+r+`" alt="CSS 层叠样式优先级"></p><p>这明显是不讲武德了，但问题还是要解决。为了样式的正确还原，有两个解决方案：</p><ul><li>增加封装样式的特异性（specity）</li><li>不透传disabled</li></ul><p>第一种方案，就是为了弥补小程序埋的坑而因此更多的问题，比如用户如果想要自定义主题的话，要想覆盖 TDesign 的样式就需要将 specity 提得更高，因此否定了这个方案。</p><p>第二种方案，就是不将 disabled 属性透传到原生 Button，手动实现 disabled 的效果。</p><h2 id="重新实现-disabled" tabindex="-1">重新实现 disabled <a class="header-anchor" href="#重新实现-disabled" aria-label="Permalink to &quot;重新实现 disabled&quot;">​</a></h2><p>这种方案很直观，就是监听 tap 事件，然后在 disabled 的时候不触发 tap 事件即可：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">t-button</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">bind</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">tap</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">handleTap</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// t-button</span></span>
<span class="line"><span style="color:#82AAFF;">Component</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">handleTap</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">data</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">disabled</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">triggerEvent</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">tap</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>但此时需要考虑一种情况，就是有 open-type 的时候，会没法阻止。</p><p>此时直观的想法是在每个开发能力对应的事件里，对 disabled 做特殊处理，但其实也是不合理的。因为这样没法阻止 open-type 的事件发生，用户仍然会看到对应的授权弹窗。</p><p>另外一种方案，反而会合理许多，但也 hack 许多。就是在 disabled 的时候，不透传 open-type：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">open-type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">{{ disabled ? &#39;&#39; : openType }}</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span></code></pre></div><h2 id="事件问题" tabindex="-1">事件问题 <a class="header-anchor" href="#事件问题" aria-label="Permalink to &quot;事件问题&quot;">​</a></h2><p>在使用 t-button 组件的时候，就发现问题了，tap 事件触发了两次：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">t-button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">bind</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">tap</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">handler</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">Page</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">handler</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// 触发两次</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>这个问题也是比较典型的事件模型问题：</p><p><img src="`+i+'" alt="事件模型图"></p><p>因此，需要通过 catch 事件来捕获 tap 事件，避免冒泡：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">t-button</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">capture-catch</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">tap</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">handleTap</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>这样解决了上面的问题，但此时会导致 open-type 的事件不会触发。因此不能使用 capture-catch 而是使用 catch：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">class</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">t-button</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">catch</span><span style="color:#89DDFF;">:</span><span style="color:#C792EA;">tap</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">handleTap</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>最后 button 的组件完成了，我就好奇业界其他组件库是如何实现的。</p><p>于是我去看了下 vant 和 lin-ui，这两个算是微信小程序组件库的两个明星仓库。</p><p>结果发现，这两个库都选择了不透传 disabled，自行实现disabled。但在事件问题上，三个组件库走在了不同的路上：</p><ul><li>vant 的 tap 事件是不受 disabled 影响的，新增了一个 disabled 时不触发的 click 事件。</li><li>lin-ui 则是会在有 open-type 的时候，disabled 失效。</li><li>TDesign 的 tap 的事件保持了和原生一致。</li></ul>',34);function u(a,h,b,C,g,m){return l(),p("div",null,[s("h1",D,[t(o(a.$frontmatter.title)+" ",1),y]),d])}const q=n(F,[["render",u]]);export{_ as __pageData,q as default};
