import{_ as o,o as c,c as r,k as e,a,t as d,S as n}from"./chunks/framework.c5ba3aa3.js";const f=JSON.parse('{"title":"HTTP 常用安全头","description":"","frontmatter":{"title":"HTTP 常用安全头","date":"2016-05-09T21:02:49.000Z","tags":["网络安全","HTTP"],"desc":"web safe,web安全,网络安全,http,http安全头部","toc":true,"categories":["计算机网络"]},"headers":[],"relativePath":"practice/http-safe-header.md","filePath":"practice/http-safe-header.md","lastUpdated":1691668833000}'),s={name:"practice/http-safe-header.md"},i={id:"frontmatter-title",tabindex:"-1"},l=e("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),p=n('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>Security - Elephant in the room，指显而易见而又被忽略的事实。用这个短语形容<code>web</code>安全，不能更生动形象。最近项目涉及到一些<code>web</code>安全的东西，就来总结一下相关的HTTP安全头部。</p><h2 id="content-security-policy" tabindex="-1"><a href="http://content-security-policy.com/" target="_blank" rel="noreferrer">Content-Security-Policy</a> <a class="header-anchor" href="#content-security-policy" aria-label="Permalink to &quot;[Content-Security-Policy](http://content-security-policy.com/)&quot;">​</a></h2><p><strong>作用</strong>：防止的内容注入（减缓了<code>XSS</code>攻击，恶意<code>iframe</code>注入）</p><p><strong>不足</strong>：目前只支持现代浏览器，对浏览器有要求，要求如下：</p><table><thead><tr><th>header</th><th>Chrome</th><th>FireFox</th><th>Safari</th><th>Internet Explorer</th></tr></thead><tbody><tr><td>Content-Security-Policy <code>CSP Level 2</code></td><td>40+ Full January 2015</td><td>31+ PartialJuly 2014</td><td>-</td><td>-</td></tr><tr><td>Content-Security-Policy <code>CSP 1.0</code></td><td>25+</td><td>23+</td><td>7+</td><td>Edge 12 build 10240+</td></tr></tbody></table><p><strong>分析</strong>：</p><ol><li><p>由于HTML的<code>img</code>、<code>script</code>、<code>css</code>是可以跨域的，这就导致了XSS缺陷。CSP可以设置<code>default-src</code>、<code>script-src</code>、<code>img-src</code>等等来限制HTML资源的加载</p></li><li><p><code>script-src</code>可以设置两个特殊的值（<code>unsafe-inline</code>、<code>unsafe-eval</code>）。<code>unsafe-inline</code>代表不能执行内<code>script</code>，这就对<code>XSS</code>增添了一次防御，不过这样对开发人员有一定的规范。<code>unsafe-eval</code>则是代表不能执行<code>eval</code>方法(这是一个比较BUG级的函数，它会把传入的参数全部当做<code>JS</code>代码解释并且执行)</p></li><li><p><code>sandbox</code>沙盒则适用于同源策略的<code>webapp</code>，可以限制新标签页面打开等等。</p></li><li><p><code>report-uri</code>这个属性可以设置一个<code>URL</code>，然后会把<code>CSP</code>的失败信息<code>POST</code>到这个<code>URL</code>。我们则可以记录这个有用的信息用来安全性分析。</p></li></ol><h2 id="strict-transport-security" tabindex="-1"><a href="https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security" target="_blank" rel="noreferrer">Strict Transport Security</a> <a class="header-anchor" href="#strict-transport-security" aria-label="Permalink to &quot;[Strict Transport Security](https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security)&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload]</span></span></code></pre></div><p><strong>作用</strong>：告诉浏览器接下来的一定时间内（自己设置）只能用<code>HTTPS</code>访问。这个只会让用<code>HTTPS</code>访问的用户继续使用<code>HTTPS</code>。而HTTP访问的则无效。</p><p><strong>分析</strong>：研究了一下alipay.com的做法。用户输入的时候，绝大部分都不会手动输入<code>HTTPS</code>。所以第一次访问的时候，都是以<code>HTTP</code>访问，这时负载服务器就应该返回一个<code>301</code>跳转给客户端，让客户端跳转到<code>HTTPS</code>的服务下。由于有了<code>HSTS</code>的头部，下次用户再次以<code>HTTP</code>访问的时候，浏览器会自己做<code>307</code>跳转到<code>HTTPS</code>请求。</p><p><strong>实际开发遇到的问题</strong>：</p><p>由于公司使用阿里云的<code>SLB</code>负载均衡，无法实现<code>301</code>跳转，于是使用了<code>node</code>再开启一个服务，用于接受来自<code>SLB</code>80端口的请求，然后返回一个<code>301</code>状态码并在<code>Location</code>头部加上<code>HTTPS</code>的地址。真正的<code>node</code>服务只接受<code>SLB</code>443接口的请求。</p><h2 id="x-content-type-options" tabindex="-1"><a href="https://msdn.microsoft.com/en-us/library/gg622941.aspx" target="_blank" rel="noreferrer">X-Content-Type-Options</a> <a class="header-anchor" href="#x-content-type-options" aria-label="Permalink to &quot;[X-Content-Type-Options](https://msdn.microsoft.com/en-us/library/gg622941.aspx)&quot;">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">X-Content-Type-Options: nosniff</span></span></code></pre></div><p><strong>作用</strong>：互联网上的资源有各种类型，通常浏览器会根据响应头的<code>Content-Type</code>字段来分辨它们的类型。例如：<code>text/html</code>代表html文档，<code>image/png</code>是PNG图片，<code>text/css</code>是CSS样式文档。然而，有些资源的<code>Content-Type</code>是错的或者未定义。这时，某些浏览器会启用<code>MIME-sniffing</code>来猜测该资源的类型，解析内容并执行。</p><p>例如，我们即使给一个<code>html</code>文档指定<code>Content-Type</code>为<code>text/plain</code>，在<code>IE8</code>中这个文档依然会被当做<code>html</code>来解析。利用浏览器的这个特性，攻击者甚至可以让原本应该解析为图片的请求被解析为<code>JavaScript</code>。</p><p><strong>实际开发遇到的问题</strong>：</p><p>在IE下图片验证码不能显示。<br> 分析后得出，是因为图片验证码返回的时候没有返回<code>content-type</code>这个文件类型的头部。所以<code>IE</code>不能识别文件类型。<br> 解决办法是修改图片验证码插件在返回图片是增加头部<code>content-type</code>：<code>image/jpg</code></p><h2 id="参考" tabindex="-1">参考： <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考：&quot;">​</a></h2><ul><li><p><a href="https://blog.risingstack.com/node-js-security-checklist/" target="_blank" rel="noreferrer">Node.js Security Checklist</a></p></li><li><p><a href="http://expressjs.com/en/advanced/best-practice-security.html" target="_blank" rel="noreferrer">Express.js官方的安全性最佳实践指导</a></p></li><li><p><a href="http://www.cnblogs.com/bangerlee/archive/2013/04/06/3002142.html" target="_blank" rel="noreferrer">xss攻击入门</a></p></li></ul>',22);function h(t,u,T,g,m,y){return c(),r("div",null,[e("h1",i,[a(d(t.$frontmatter.title)+" ",1),l]),p])}const b=o(s,[["render",h]]);export{f as __pageData,b as default};
