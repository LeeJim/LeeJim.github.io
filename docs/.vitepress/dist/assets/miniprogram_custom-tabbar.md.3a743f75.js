import{_ as o,o as t,c as n,k as a,a as e,t as l,S as p}from"./chunks/framework.7f03344f.js";const r="/compare.jpg",f=JSON.parse('{"title":"小程序中实现自定义标签栏","description":"","frontmatter":{"title":"小程序中实现自定义标签栏","tags":["小程序","自定义组件"],"desc":"小程序如何自定义tabbar","toc":true,"categories":["小程序"],"date":"2020-3-29"},"headers":[],"relativePath":"miniprogram/custom-tabbar.md","filePath":"miniprogram/custom-tabbar.md","lastUpdated":null}'),c={name:"miniprogram/custom-tabbar.md"},i={id:"frontmatter-title",tabindex:"-1"},b=a("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),F=p('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>由于打算在首页全屏展示壁纸，但是首页属于tabbar页面之一，会被底部的tabbar遮挡一部分。</p><p>因此要考虑使用新特性：自定义tabbar。可以看下前后效果对比：</p><p><img src="'+r+`" alt=""></p><h2 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h2><p>原本想着自行写个组件渲染即可，但看到官方有提供自定义tabbar，那么就优先使用官方提供的吧。</p><p>从 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar" target="_blank" rel="noreferrer">小程序的官网文档</a> 可以看到，自定义tabbar依赖基础库2.5.0以上，相关配置如下：</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">tabbar</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">custom</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>设置了<code>custom</code>之后，小程序不再渲染原有的tabbar，开始渲染自定义tabbar。</p><p>而这个自定义tabbar的组件则需要自己写（感觉好像绕回来了）</p><h2 id="实践" tabindex="-1">实践 <a class="header-anchor" href="#实践" aria-label="Permalink to &quot;实践&quot;">​</a></h2><p>按照官网文档的描述，在根目录上创建组件的文件夹，命名<code>custom-tab-bar</code>，里面的文件和正常的组件保持一致。</p><p>此时就可以将组件的样式和逻辑稍作调整：</p><ul><li>当进入首页时，背景色改成透明</li><li>进入其他页面，背景色改回白色</li></ul><p>这里需要注意的是，并不是多个页面渲染同个tabbar组件，而是每个页面独自渲染各自的tabbar，但不需要在每个页面的<code>WXML</code>里显式引用。</p><h3 id="选中态" tabindex="-1">选中态 <a class="header-anchor" href="#选中态" aria-label="Permalink to &quot;选中态&quot;">​</a></h3><p>由于每个页面都各自渲染了tabbar组件，而这个组件的初始化时，都将设置第一个tab为选中态。因此存在这样的问题：tabbar如何正确显式当前的选中态？</p><p>根据官网的描述，即是提供了接口<code>getTabBar</code>，可以获取tabbar的实例。在当前页面下，手动setData更新选中态（这不就很蠢）</p><p>需要在tabbar包含的每个页面的onShow里这样设置：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">Page</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">onShow</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">getTabBar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">function</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">getTabBar</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setData</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> selected</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// 0代表第一个</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><blockquote><p>此时如果能监听到路由的变化，那么可以统一处理。后续考虑封装个Router</p></blockquote><h3 id="兼容性" tabindex="-1">兼容性 <a class="header-anchor" href="#兼容性" aria-label="Permalink to &quot;兼容性&quot;">​</a></h3><p>为了测试兼容性，我尝试将基础库调至2.5.0以下。此时，自定义tabbar和原有的tabbar都没有渲染。通过多方测试，发现只有去掉<code>custom:true</code>才会恢复渲染tabbar。</p><p>所以，如果对兼容性要求比较高的小程序，应该避免这个坑。采取自行实现组件，自行引用的方式实现自定义tabbar。</p><blockquote><p>如果你知道有什么兼容办法，欢迎和我联系。</p></blockquote>`,25);function D(s,y,d,h,u,m){return t(),n("div",null,[a("h1",i,[e(l(s.$frontmatter.title)+" ",1),b]),F])}const C=o(c,[["render",D]]);export{f as __pageData,C as default};
