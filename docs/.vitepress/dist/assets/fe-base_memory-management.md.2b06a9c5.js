import{_ as e,o as n,c as o,k as a,a as l,t,S as p}from"./chunks/framework.7f03344f.js";const u=JSON.parse('{"title":"JavaScript 内存管理","description":"","frontmatter":{"title":"JavaScript 内存管理","date":"2017-03-05T09:40:57.000Z","tags":["JavaScript","内存管理","垃圾回收"],"desc":"js内存管理 js垃圾回收","toc":true,"categories":[["前端基础"],"浏览器"]},"headers":[],"relativePath":"fe-base/memory-management.md","filePath":"fe-base/memory-management.md","lastUpdated":null}'),r={name:"fe-base/memory-management.md"},c={id:"frontmatter-title",tabindex:"-1"},i=a("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),y=p(`<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>JavsScript在变量创建的时候分配内存，然后在它们不再使用时“自动”释放，就是被称为垃圾回收。“自动”这个词很容易让人混淆，让我们误以为不需要去管理内存。其实这个“自动”也有其处理的逻辑，深入地了解其运行机制，能让我们写出更健壮的JavaScript代码，免去内存泄漏的烦恼。</p><h2 id="内存生命周期" tabindex="-1">内存生命周期 <a class="header-anchor" href="#内存生命周期" aria-label="Permalink to &quot;内存生命周期&quot;">​</a></h2><p>不管什么程序语言，内存生命周期基本是一致的：</p><ol><li>分配你所需要的内存</li><li>使用分配到的内存（读／写）</li><li>不需要时将其回收</li></ol><p>其中，第一步和第二步并不需要我们关心。我们关注的是：什么情况才会被当成不需要的时候。</p><h2 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h2><p>JavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。它的原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。</p><p>我们都知道局部函数的变量都是在运行的时候分配内存，然后执行结束的时候释放内存。在这种情况下，很容易判断变量是否还有存在的必要。但并非所有情况都这么容易判断的。因此垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。用于标识无用变量的策略通常有两种：</p><p>－ Reference-counting（引用计数） － Mark-and-sweep（标记清除）</p><h4 id="引用" tabindex="-1">引用 <a class="header-anchor" href="#引用" aria-label="Permalink to &quot;引用&quot;">​</a></h4><p>一个对象如果有访问另一个对象的权限，就叫做一个对象引用另一个对象。</p><h4 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h4><p>其实这是一个很粗略的方式：只要一个对象没有被引用，那就把它当垃圾处理了。这个算法很简单实现，但是有一个致命的问题就是无法解决<strong>循环引用</strong>的问题：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> div</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onload</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">div</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getElementById</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">myDivElement</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">div</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">circularReference</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">div</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">div</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">lotsOfData</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Array</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">10000</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">join</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>这时DOM 元素<code>myDivElement</code>就永远不会被回收了。</p><h4 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to &quot;标记清除&quot;">​</a></h4><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p><p>这个算法假定是有一系列的被称为root的对象，也就是根对象，在JavaScript就是全局对象<code>window</code>。</p><p>然后垃圾回收器就定期地从全局对象开始扫描，寻找所有被全局对象或其他对象引用的对象。</p><p>这句话略绕口，简而言之就是，首先寻找到所有被全局对象引用的对象，然后再寻找这些对象所引用的对象，以此循环递归寻找到所有的可被访问对象。</p><p>这样，垃圾回收器就可以知道所有的可访问对象和不可访问对象。</p><p>本文主要内容参考：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noreferrer">Memory Management</a></p>`,23);function F(s,d,D,m,h,A){return n(),o("div",null,[a("h1",c,[l(t(s.$frontmatter.title)+" ",1),i]),y])}const _=e(r,[["render",F]]);export{u as __pageData,_ as default};
