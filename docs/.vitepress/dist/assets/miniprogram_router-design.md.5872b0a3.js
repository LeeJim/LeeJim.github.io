import{_ as o,o as e,c as n,k as a,a as p,t as l,S as t}from"./chunks/framework.7f03344f.js";const r="/miniprogram/router/路由权限控制.png",c="/miniprogram/router/router-methods.png",i="/miniprogram/router/demo1.png",d="/miniprogram/router/demo2.png",y="/miniprogram/router/demo3.png",D="/miniprogram/router/demo4.png",k=JSON.parse('{"title":"浅谈小程序路由的封装设计","description":"","frontmatter":{"title":"浅谈小程序路由的封装设计","date":"2020-06-02T19:29:17.000Z","tags":["小程序"],"categories":["小程序"],"toc":true},"headers":[],"relativePath":"miniprogram/router-design.md","filePath":"miniprogram/router-design.md","lastUpdated":null}'),u={name:"miniprogram/router-design.md"},F={id:"frontmatter-title",tabindex:"-1"},h=a("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),A=t('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>微信官方提供了基础的路由能力，在日常的开发中虽已够用，但随着开发的深入，会遇到许多值得思考提炼的问题。本文将探讨作者在微信小程序（以下简称小程序）开发当中遇到的问题，以及解决方案设计。</p><p>参考“WHY-HOW-WHAT&quot;黄金圈思维法则，首先讲述为什么小程序的路由需要封装设计，也就是存在哪些问题，需要封装处理？</p><h2 id="存在的问题" tabindex="-1">存在的问题 <a class="header-anchor" href="#存在的问题" aria-label="Permalink to &quot;存在的问题&quot;">​</a></h2><h3 id="路由跳转的路径与文件路径耦合" tabindex="-1">路由跳转的路径与文件路径耦合 <a class="header-anchor" href="#路由跳转的路径与文件路径耦合" aria-label="Permalink to &quot;路由跳转的路径与文件路径耦合&quot;">​</a></h3><p>小程序的路由跳转使用的是真实文件路径，因此若文件的结构发生变化，必会影响到所有的页面的跳转路径。</p><p>笔者在实际开发中就遇到这个问题，以小程序分包举例。</p><p>小程序的分包是以文件夹为单位的。如果要将一系列的页面拆分成分包，则需要将这些文件移至同个目录之下，因此必然导致路由的跳转路径发生变更。如果此时路由跳转均是直接通过文件路径跳转的话，则需要全局改动，导致的工作量不少。</p><p>另外，当开发团队比较庞大时，不同的业务之间总会存在互相跳转的情况。当其中一个页面地址发生变更时，其他业务跳转到该页面的路径都需要手动变更。若此时通知不及时，或者遗漏了一些地方，导致跳转失败，终会酿成大错。</p><h3 id="路由传参" tabindex="-1">路由传参 <a class="header-anchor" href="#路由传参" aria-label="Permalink to &quot;路由传参&quot;">​</a></h3><p>目前小程序支持的传参方式，即通过跳转路径上的 query 查询参数。</p><p>通过 query 传参的问题，与在 Web 上 URL 传参是一致的，比如：</p><ul><li>query 的参数长度有限</li><li>query 只能传递可序列化的数据</li><li>导航前需手动序列化，到达目标页面后需反序列化</li></ul><h3 id="条件导航" tabindex="-1">条件导航 <a class="header-anchor" href="#条件导航" aria-label="Permalink to &quot;条件导航&quot;">​</a></h3><p>在日常业务中，会存在一些页面需要一定条件才允许进入的。</p><p>举个例子，会员服务是一种很常见的能力，而会员中心的进入条件是：</p><ul><li>该用户已经完成登录</li><li>该用户是本产品的会员</li></ul><p>一般情况下，这有特定准入资格的页面的导航逻辑是这样的：</p><p><img src="'+r+`" alt="路由权限控制"></p><p>这种方式简单明了，但存在一个问题：需要每次跳转前主动判断，逻辑冗余以外，还可能被遗漏。</p><h2 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to &quot;思路&quot;">​</a></h2><p>由于小程序本身已提供了基础的路由导航能力，不像 react、vue 那样需要从底层进行封装，从而提供路由能力。但是，本质上小程序可以理解成类 vue 这样的框架，因此可以从 vue 的路由库 vue-router 上找到灵感，从而解决以上问题。</p><h3 id="命名路由" tabindex="-1">命名路由 <a class="header-anchor" href="#命名路由" aria-label="Permalink to &quot;命名路由&quot;">​</a></h3><p>使用 <strong>命名路由</strong> 的方式可以解决前文提及的跳转路径和文件真实路径耦合问题。</p><p>通过 <code>Map</code> 来映射 <strong>页面ID</strong> 和 <strong>页面地址</strong>，路由跳转时，仅能使用 <strong>页面ID</strong> 进行路由跳转。</p><p>下面以导航至首页举例：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// before</span></span>
<span class="line"><span style="color:#A6ACCD;">wx</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">switchTab</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pages/home/index</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// after</span></span>
<span class="line"><span style="color:#A6ACCD;">router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">go</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">home</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><blockquote><p>由于小程序有 tab 页面和普通页面之分，因此导航至 tab 页时需使用 switchTab</p></blockquote><p>细心的读者可能会发现上文使用了 <code>go</code> 方法，而不是 <code>switchTab</code>。其实，具体哪些页面属于 tab 页面，在 <code>app.json</code> 已经明确配置。对于使用者来说，不需要关心跳转的页面是属于哪种类型，这些细节都应该统一在底层封装好。下面罗列 <code>Router</code> 与官方 API 的对应关系：</p><p><img src="`+c+`" alt="路由的方法"></p><blockquote><p>Router API的设计原则是保持简单，以及尽量保持与web规范一致</p></blockquote><h3 id="参数传递" tabindex="-1">参数传递 <a class="header-anchor" href="#参数传递" aria-label="Permalink to &quot;参数传递&quot;">​</a></h3><p>微信官方提供的 query 方式传参，若参数是普通数据类型（如<code>Number</code>、<code>String</code>）时可以直接使用；但若是涉及到复杂数据类型（如<code>Array</code>、<code>Object</code>）时，需要先做序列化处理，当数据较为庞大时，性能的损耗还是比较明显的。</p><p>因此，在内存上传递参数是比较便利且容易想到的办法。</p><p>利用数据字典，将 <code>页面ID</code> 作为 <code>key</code>、传递的参数作为 <code>value</code>，写入 <code>Router</code> 的 <code>state</code>：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">go</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">pageID</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">params</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// do something...</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">router</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">pageID</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">params</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>在目标页面上，可以通过 <code>router.getParams()</code> 方法，获取传递的参数。</p><blockquote><p>由于采用了命名路由的方式，可以使用 <code>页面ID</code> 作为 <code>key</code>，避免了使用跳转路径做 <code>key</code> 时，涉及到的绝对与相对路径问题。</p></blockquote><h3 id="条件导航-1" tabindex="-1">条件导航 <a class="header-anchor" href="#条件导航-1" aria-label="Permalink to &quot;条件导航&quot;">​</a></h3><p>条件导航可以使用类似 vue-router 的导航守卫来解决问题。</p><p>由于路由的能力是微信官方提供的，因此无法像 vue-router 那样提供多类型的导航守卫，但仅有全局导航守卫也足够使用。</p><p>以下仍以“会员中心”的进入逻辑举例，并简要介绍实现思路：</p><p><img src="`+i+'" alt=" "></p><p>其中，to和from目前是pageID，其实可以封装更多信息，以保证导航守卫可以尽可能拥有更多的信息。因此to可以理解成是即将进入的页面路由对象，而from则是当前正要离开的路由对象。</p><p>路由对象可以包含以下信息：</p><ul><li><code>pageID</code>：页面 ID</li><li><code>path</code>：页面 ID 对应的 path</li><li><code>params</code>：传递的参数</li><li><code>query</code>: URL的查询参数</li></ul><h3 id="配置信息" tabindex="-1">配置信息 <a class="header-anchor" href="#配置信息" aria-label="Permalink to &quot;配置信息&quot;">​</a></h3><p>由前文提到的 <strong>命名路由</strong> 做法需要一个配置文件来关联 <code>页面ID</code> 与 <code>页面路径</code> 的关系。</p><p>页面的配置信息，则是使用 <code>router.config.js</code> 设置，然后通过构建工具编译转成 <code>app.json</code>。</p><p>以下是 <code>route.config.js</code>：</p><p><img src="'+d+'" alt=" "></p><blockquote><p>其中，跳转首页则是 <code>router.go(&#39;home&#39;)</code>；而跳转分包 <code>health</code> 的首页则是使用 <code>router.go(&#39;health.home&#39;)</code></p></blockquote><p>通过以上的配置文件，使用构建工具转换成微信官方可识别的 <code>app.json</code> 配置：</p><p><img src="'+y+`" alt=" "></p><h3 id="辅助函数" tabindex="-1">辅助函数 <a class="header-anchor" href="#辅助函数" aria-label="Permalink to &quot;辅助函数&quot;">​</a></h3><p>在日常开发当中，经常会用到一些和路由相关的通用辅助函数，如获取当前页面，获取上个页面等。这些辅助函数都应该统一抽象封装，避免代码冗余。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">router</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">utils </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">getCurPage</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 获取当前页面信息</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">pages</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">getCurrentPages</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">len</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">pages</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span></span>
<span class="line"><span style="color:#F07178;">        </span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">pages</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">len</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">getPrePage</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 获取上个页面信息</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">getParams</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 获取传递的参数</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">getPageID</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">path</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 通过path找到pageID</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h3 id="navigator-组件" tabindex="-1">navigator 组件 <a class="header-anchor" href="#navigator-组件" aria-label="Permalink to &quot;navigator 组件&quot;">​</a></h3><p>微信官方除了提供 <code>API</code> 用于导航以外，还提供了 <code>navigator</code> 组件。</p><blockquote><p>另外还有 <code>functional-page-navigator</code> 是用于插件当中，不能在小程序包使用，因此本文暂且将其忽略。</p></blockquote><p>由于 <code>navigator</code> 的跳转参数仍是使用 <code>path</code>，因此笔者将其进行二次封装，改造成可以通过 <code>pageID</code> 跳转：</p><p><img src="`+D+'" alt=" "></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>由于小程序相对比较封闭，因此在路由上能做的东西比较有限。</p><p>但路由又与许多概念有千丝万缕的关系。比如路由与文件结构关联，而文件结构又影响到分包的设计，环环相扣，影响到的地方则会越来越多。</p><p>因此，能提前看到本文提到的可能出现的问题，也许对后续的小程序开发有一定的参考意义。</p><p>另外，前文提到的很多问题，在早期开发，或者没有深入开发之前，都不会遇到。但是当你开始经历前文提到的那些问题时，往往此时的改造成本已经很大了。因此希望本文能给你带了一些启发，在早期规避这些问题，那本文的使命就达到了。</p>',67);function C(s,g,m,b,f,q){return e(),n("div",null,[a("h1",F,[p(l(s.$frontmatter.title)+" ",1),h]),A])}const P=o(u,[["render",C]]);export{k as __pageData,P as default};
