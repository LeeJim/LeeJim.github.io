import{_ as a,o,c as n,k as s,a as l,t as p,S as t}from"./chunks/framework.c5ba3aa3.js";const c="/vue3/vue-core-modules.png",r="/vue3/tree-data-flow.png",f=JSON.parse('{"title":"关于 Vue3 的 Proxy 引起的问题","description":"","frontmatter":{"title":"关于 Vue3 的 Proxy 引起的问题","date":"2021-05-28T17:43:34.000Z","tags":null,"categories":["vue"],"toc":true},"headers":[],"relativePath":"vue/vue3-with-proxy.md","filePath":"vue/vue3-with-proxy.md","lastUpdated":1691668833000}'),d={name:"vue/vue3-with-proxy.md"},y={id:"frontmatter-title",tabindex:"-1"},i=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),F=t('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>Vue3 是 Vuejs 新出的 3.0 版本，性能以及代码可维护性都提升了许多，也解决了许多 Vue2 中使用不便的地方。 此外，由于使用了 Proxy 来实现 Reactivity，所以对客户端的要求也就更高了，但总的来说，Vue3 的普及是势不可挡的。</p><p>TDesign 是汇集了公司多个 Oteam 的结晶，包括了多种框架多种终端的组件。</p><p>其中，Tree 可以说是组件库里最复杂的组件了，可以说是没有之一。</p><p>这次分享的内容是在我将 Tree 由 Vue2 迁移至 Vue3 过程中遇到的问题、分析过程以及最终的解决方案。</p><h2 id="迁移策略" tabindex="-1">迁移策略 <a class="header-anchor" href="#迁移策略" aria-label="Permalink to &quot;迁移策略&quot;">​</a></h2><p>从 Vue2 升级至 Vue3，可以从官方的 <a href="https://v3.vuejs.org/guide/migration/introduction.html" target="_blank" rel="noreferrer">《Migration Guide》</a>可以看到了解到底有哪些 breaking changes。</p><p>升级的最小成本就是将 breaking changes 修复即可。</p><p>至于其他更好用的特性（如 <code>Composition API</code>、<code>Fragments</code> 等），属于非必需特性，可以放在后置再进行优化。其中的缘由是因为 Vue2 也在高速运转中，仍处于不稳定的状态，不对代码进行较大改动是为了之后可以方便地同步 Vue2 最新的代码。</p><h2 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h2><p>Vue 的核心模块有三个：Reactivity Module、Compiler Module、Renderer Module。</p><p><img src="'+c+`" alt="Vue 核心模块"></p><p>其中，Compiler Module 是将 template 转换成 render function，日常开发不会遇到问题。</p><p>而 Reactivity Module 则从 <code>Object.defineProperty</code> 升级成 <code>Proxy</code> 的形式实现，会存在原理上的不同，导致代码的实现思路也会受影响。在较复杂逻辑中比较容易出现问题。</p><p>Renderer Module 则是核心的渲染逻辑。问题常出现在 Patch 阶段，需要了解其中的 diff 算法。</p><h2 id="代码结构" tabindex="-1">代码结构 <a class="header-anchor" href="#代码结构" aria-label="Permalink to &quot;代码结构&quot;">​</a></h2><p>在开始迁移之前，先了解了一下 Tree 的代码结构：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">- common</span></span>
<span class="line"><span style="color:#A6ACCD;">  - tree-store.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">  - tree-node.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">- src</span></span>
<span class="line"><span style="color:#A6ACCD;">  - tree</span></span>
<span class="line"><span style="color:#A6ACCD;">    - td-tree.tsx</span></span>
<span class="line"><span style="color:#A6ACCD;">    - tree-item.tsx</span></span></code></pre></div><blockquote><p>common里面的代码是tree的公共逻辑，会在多个框架多个终端之间共享。</p></blockquote><p>数据的流动：</p><p><img src="`+r+`" alt="TDesign 树的数据流动"></p><h1 id="状况百出" tabindex="-1">状况百出 <a class="header-anchor" href="#状况百出" aria-label="Permalink to &quot;状况百出&quot;">​</a></h1><h2 id="渲染死循环" tabindex="-1">渲染死循环 <a class="header-anchor" href="#渲染死循环" aria-label="Permalink to &quot;渲染死循环&quot;">​</a></h2><p>通过断点发现，在不断地渲染 <code>td-tree</code>，其中就卡在 patchChildren 的逻辑：<code>vue-next/packages/runder-core/src/renderer.ts:1771</code>，下面是我摘选的部分代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#A6ACCD;"> (i </span><span style="color:#89DDFF;">&lt;=</span><span style="color:#A6ACCD;"> e1 </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;=</span><span style="color:#A6ACCD;"> e2) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">c1</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">n2</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">c2</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">optimized</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">?</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">cloneIfMounted</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">c2</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">VNode</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">normalizeVNode</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">c2</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">]))</span></span>
<span class="line"><span style="color:#89DDFF;">		</span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这是一个简单的数组赋值，为什么在 Vue2 正常运行，而在 Vue3 则发生了死循环呢？</p><p>是因为我们 <code>td-tree</code> 的渲染函数是这样的：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineComponent</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">render</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">TreeNodes</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">transition-group</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#A6ACCD;">TreeNodes</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#FFCB6B;">transition-group</span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">	</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>而 <code>TreeNodes</code> 则是 <code>TreeItem</code> 实例的集合：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">treeNodes</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">TreeItem</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#C792EA;">key</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#C792EA;">node</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">node</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#C792EA;">treeScope</span><span style="color:#89DDFF;">={</span><span style="color:#A6ACCD;">treeScope</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={this.</span><span style="color:#A6ACCD;">handleClick</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#C792EA;">onChange</span><span style="color:#89DDFF;">={this.</span><span style="color:#A6ACCD;">handleChange</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">/&gt;</span><span style="color:#A6ACCD;">))</span></span></code></pre></div><p>所以，在 patch 的时候，对当前 VNode Child 进行了替换。</p><p>由于Vue3使用了 <code>Proxy</code> 而不再是Vue2的 <code>Object.defineProperty</code>，因此通过数组的下标进行赋值也会被监听到，自然就又重新进入了渲染流程，最终导致了渲染死循环。</p><p>解决办法：避免使用 VNode 数组。</p><p>在当前的组件里，就是将 <code>treeNodes</code> 的元素改成 <code>node</code>，而不是 <code>tree-item</code> 的 <code>VNode</code>。</p><p>最终 <code>td-tree</code> 的渲染函数是这样的：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineComponent</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">render</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">TreeNodes</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">transition-group</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">TreeNodes</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">map</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;font-style:italic;">node</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderItem</span><span style="color:#A6ACCD;">(node))</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#FFCB6B;">transition-group</span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">	</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><h2 id="数据变更不渲染" tabindex="-1">数据变更不渲染 <a class="header-anchor" href="#数据变更不渲染" aria-label="Permalink to &quot;数据变更不渲染&quot;">​</a></h2><p>为了实现多框架之间可以实现逻辑复用，所以 <code>tree</code> 的很多复杂逻辑计算都被封装在一个公共模块里。</p><p>而其中 <code>tree-item</code> 的很多逻辑存在于 <code>common/tree-node.ts</code> 里面。</p><p>按理说，Vue2 运行正常的情况下，我只需要改动 Vue3 的 breaking changes 的地方，其他逻辑我是不需要改动的。而且由于公共模块的部分是多框架复用的，所以我是不应该改动这部分的，除非 Vue2 同样存在问题。</p><p>诡异的情况发生了，在测试 <a href="http://tdesign.woa.com/vue/components/tree#18-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E8%8A%82%E7%82%B9" target="_blank" rel="noreferrer">异步加载节点</a> 的 case 的时候，发现 <code>loading</code> 的 <code>icon</code> 一直不会消失。</p><p>于是我开始梳理各种 <code>tree</code> 的渲染逻辑，最后通过数据的追踪，发现其实当前的 <code>node</code> 的 <code>loading</code> 值已经变成了 <code>false</code>，只是<code>tree-item</code>的 render 没有被触发而已。</p><p>表面的原因发现了，但深层的原因是为什么呢？</p><p>其实，这又是 Vue3 和 Vue2 的响应式实现的差异引起的问题。</p><p>在 Vue2 中，每个被当作 <code>property</code> 传到组件的值，会通过 <code>Object.defineProperty</code> 来对每个 <code>key</code> 设置 <code>getter</code> 和 <code>setter</code>。</p><p>以当前的组件举例：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">tree-item</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">:node</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">node</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span></code></pre></div><p>我们将 <code>node</code> 当作 <code>property</code> 传给 <code>tree-item</code> 的时候，Vue 就将 <code>node</code> 的每个 <code>key</code> 设置了 <code>getter</code> 和 <code>setter</code>，其中关键的是 <code>setter</code>，如果改变了<code>node</code> 的任意属性值，就会触发了 <code>setter</code> 与此同时就会对当前这个 <code>tree-item</code> 进行渲染。</p><p>而在 Vue3 中，由于<code>Object.definedProperty</code> 的各种局限，所以采用了更先进的 <code>Proxy</code> 来实现响应式。</p><p>这也就带了问题。<code>Proxy</code> 的机制要求我们访问 <strong>代理对象</strong> 而不是源对象，但由于 <code>tree</code> 的封装设计，只会在源对象上进行属性值变更，也就不会触发<code>tree-item</code>的渲染了。</p><p>找到了核心问题，解决思路有很多种：</p><ol><li>让公共部分的逻辑在 <strong>代理对象</strong> 上进行，而不是源对象（不能因为版本的差异去影响公共逻辑，所以这个方案 pass）</li><li><code>tree-item</code> 不再使用 <code>tree-store</code> 返回的 <code>node</code>，而是新的 <code>Object</code>。在 <code>tree-store</code> 触发 <code>update</code> 时，再将 <code>node</code> 的每个 <code>key</code> 值进行比较，逐个<code>update</code>，同时也就可以触发渲染了。</li></ol><h1 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h1><p>上面遇到的两个问题都是由 <code>Vue3</code> 的 <code>Reactivity</code> 机制变更导致的，均不是 <code>Migration Guide</code> 里有提到的 <code>breaking changes</code>，都属于 Vue3 的核心实现机制的改变。</p><p>因此，要想顺利完成 Vue2 到 Vue3 的升级，最好是能理解核心思想的改变，以及能熟悉框架的源码。</p>`,55);function D(e,C,A,u,h,m){return o(),n("div",null,[s("h1",y,[l(p(e.$frontmatter.title)+" ",1),i]),F])}const b=a(d,[["render",D]]);export{f as __pageData,b as default};
